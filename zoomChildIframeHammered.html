<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="initial-scale=1">

<title>Child: Hammered Iframe</title>
<style>

html, body, div, img {
    padding: 0;
    margin: 0;
    border: 0;
}

html, body {
    background-color: purple;
    border: 0px solid red;
}

#wrapper {
    border: 5px solid yellow;
    position: relative;
/*    height: 100vh;
    width: 100vw;*/
}

#targetImg {
    position: relative;
    top: 0;
    left: 0;
    width: 100%;
}

html {
    border: 3px solid red;
}
body {
    border: 3px solid white;
}

</style>
</head>

<body>


<div id='wrapper' >
    <img id='targetImg' src="./Travel_MoneyTips.png" alt="" />
    <!-- <img id='targetImg' src="http://2.bp.blogspot.com/-VQJMK8PRnI0/UjYaglEkV5I/AAAAAAAAACg/N2MkW6iorr0/s1600/30192_1600x1200-4-cute-cats.jpg" /> -->
</div>

<script src="./hammer.min.js"></script>
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script> -->


<script type="text/javascript">


var pops = parent.document.getElementById('iframeElement');
var parentLabel = parent.document.getElementById('parentLabel');
var granny = window.top.document.getElementById('iframeElement');
var grannyLabel = window.top.document.getElementById('grannyLabel');
console.log(pops);
console.log(parentLabel);
console.log(grannyLabel);

grannyLabel.innerHTML = 'woo hoo';


/* NOTE: As of Nov 2014, do not rely on viewport for iOS devices.
    iOS does not recognize the screen as the viewport for pages
    inside iframes. Instead, iOS uses the entire iframe dimension 
    as the viewport for those inside iframes.
*/


var wrapper = document.getElementById('wrapper'), 
    targetImg = document.getElementById('targetImg'),
    thisBody = document.body,
    thisHTML = document.documentElement,
    initialImgWidth = parseInt(getComputedStyle(wrapper).width),
    initialImgHeight = parseInt(getComputedStyle(wrapper).height),
    minZoom = initialImgWidth,
    maxZoom = minZoom * 2.5,
    rate = 0.33; // This slows down the response to pinch and pan

console.log(thisHTML);


granny.onload = function () {

        console.log('all aboard');
        // Once content is available, get body
        // var iframeBody = granny.contentWindow.document.body;
        var iframeBody = wrapper;
        var hammertime = new Hammer(iframeBody);

        // Register gestures as normal
        hammertime.on('pan', panImage);
        hammertime.on('doubletap', panImage);
        hammertime.on('tap', panImage);

        hammertime.get('pinch').set({ enable: true }); //Pinch is disabled by default
        hammertime.on('pinchin', function(e){ resize(e, -1); });
        hammertime.on('pinchout', function(e){ resize(e, 1); });
}




/* 'panImage' will modify left and top positions to appear that the user is scrolling on the 
/* image.  We use this approach because default scrolling will not work correctly
/* due to Hammer.js */
function panImage (e) {
    parentLabel.innerHTML = ('deltaY: ' + e.deltaY + ', deltaX: ' + e.deltaX);
    // These variables need to be local since orientation can change.
    var imgWidth = parseInt(getComputedStyle(wrapper).width),
        imgHeight = parseInt(getComputedStyle(wrapper).height),
        // frameWidth & frameHeight: Use parent iframe's size by default.  Use viewport's size as fallback.
        frameWidth = /*window.frameElement.offsetWidth ||*/ Math.max(document.documentElement.clientWidth, window.innerWidth || 0), 
        frameHeight = /*window.frameElement.offsetHeight||*/ Math.max(document.documentElement.clientWidth, window.innerHeight || 0);



    // Configure Horizontal Pan
    var minLeft = 0,
        maxLeft = frameWidth - imgWidth,
        posLeft = parseInt(getComputedStyle(targetImg).left),
        newLeft  =  posLeft + (e.deltaX * rate);

    if(imgWidth < frameWidth || newLeft > minLeft) {
        newLeft = minLeft ;
    } else if (newLeft < maxLeft) {
        newLeft = maxLeft;
    }
    targetImg.style.left = newLeft + 'px';


    // Configure Vertical Pan
    var minTop = 0,
        maxTop = frameHeight - imgHeight,
        posTop = parseInt(getComputedStyle(targetImg).top),
        newTop  =  posTop + (e.deltaY * rate);

    if(imgHeight < frameHeight || newTop > minTop) {
        newTop = minTop ;
    } else if (newTop < maxTop) {
        newTop = maxTop;
    }
    targetImg.style.top = newTop + 'px';

}



var imgWidthBeforeResize = initialImgWidth,
    imgHeightBeforeResize = initialImgHeight;

function resize (e, direction) {
    // These variables need to be local due to orientation changing
    // var imgWidth = parseInt(getComputedStyle(wrapper).width),
    //     imgHeight = parseInt(getComputedStyle(wrapper).height),
    var imgWidth = imgWidthBeforeResize,
        viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
        viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

    // Save ratio for keeping position intact
    var ratioLeft = parseInt(getComputedStyle(targetImg).left) / imgWidthBeforeResize,
        ratioTop = parseInt(getComputedStyle(targetImg).top) / imgHeightBeforeResize;   


    var delta = direction * Math.sqrt( (e.deltaY * e.deltaY) + (e.deltaX * e.deltaX) ); // Calculus formula
    var newWidth = imgWidth + (delta * rate);  // Slow the change down

    if( newWidth < minZoom) {
        newWidth = minZoom;
    } else if (newWidth > maxZoom) {
        newWidth = maxZoom;
    }

    console.log('deltaY: ' + e.deltaY + ', deltaX: ' + e.deltaX); 
    grannyLabel.innerHTML = ('deltaY: ' + e.deltaY + ', deltaX: ' + e.deltaX
        + ', <br>delta: ' + delta
        // + ', <br>frameWidth: ' + frameWidth + ', frameHeight: ' + frameHeight
        + ', <br>minZoom: ' + minZoom + ', maxZoom: ' + maxZoom 
        + ', <br>newWidth: ' + newWidth + ', <br>imgWidth: ' + imgWidth); 
    wrapper.style.width = newWidth  + 'px';
    thisBody.style.width = newWidth + 'px';
    thisHTML.style.width = newWidth + 'px';

    imgWidthBeforeResize = newWidth;



    /* Now reposition top and left according to initial ratio. */
    // var newHeight = newWidth * (imgHeight/imgWidth);  // This is the new height in theory.
    // var newLeft = ratioLeft * newWidth,
    //     newTop = ratioTop * newHeight;

    // targetImg.style.left = newLeft + 'px';
    // targetImg.style.top = newTop + 'px';

}

</script>




</body>

</html>